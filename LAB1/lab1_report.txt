01.cpp
1.runtime error;
2.在void play(int rank)，没有考虑到经过某次消除后left==0的情况；
4.由于这段代码中的void play(int rank)函数只会在进行一次消除后再次调用自身进行连消，因此只需要构造一个测例，其第一次进行消除的元素中最左端是第一个元素，即秩为0的元素。这样在进行完第一次消除后,left==0，且会调用play(left-1)导致访问越界，从而报runtime error的错。

02.cpp
1.runtime error;
2.在void play(int rank)，没有考虑到经过某次消除后珠子序列为空的情况；
4.这段代码中的void play(int rank)函数会在进行一次消除后再次调用自身进行连消，因此只需要构造一个测例，其第一次消除后整个珠子序列为空。这样在则第一次消除后仍会继续调用play(0)进行消除判断，但由于序列为空，因此play(0）访问序列中秩为0的字符值时是越界访问，会导致runtime error；

03.cpp
1.Time Limit Exceeded
2.该代码可以输出正确的结果，但是由于使用的数据结构为string，本质上是一组物理地址上连续的存储空间，可以按秩寻址，但插入时间为O（n）,因此时间复杂度为O(n^2),最坏情况下一定会超时
4.构造测例的思路是尽可能的增加运行时长。由于在string某个位置中插入一个值，其后的所有元素都得顺序后移一位，后面的元素越多时间开销越大，因此构造的测例是初始长度为最大值（500000），之后进行最多次（500000）操作，每次往序列的最前端（0）插入一个元素，且不发生消除，这样每次插入都需要将所有元素后移一位，且元素越来越多，导致Time Limit Exceeded；

04.cpp
1.Wrong Answer
2.在void play(int rank)中，相同珠子连消的搜索左边界为实际左边界-1，这导致在进行消去操作时会把前一个珠子也消除掉，且只要有两个连续珠子相同就会触发消除操作；
4.构造测例的思路是初始序列为2个不同的珠子，在插入一个与后面的珠子相同的珠子后，由于有两个连续的珠子相同，会触发连消，且把前面与其不同的珠子也消除到，输出Wrong Answer；

05.cpp
1.Time Limit Exceeded
2.参考03.cpp，该代码与03.cpp只有读入初始序列的方法有区别，由getline函数变为了cin直接输入，这两者的区别在于getline只有遇到'\n'才结束，而cin遇到空格或Tab等空白字符输入也会结束读取，但在本题条件中，初始序列中不会含有空白字符，因此此处不会产生错误，故可认为该代码与03.cpp一致。
4.参考03.cpp

06.cpp
1.Time Limit Exceeded
2.该代码的问题在于开始读入初始珠子序列并进行分段之后，不再对各分段的元素数量进行监测和重新分配，这会导致各分段的元素数量随着插入与清除的操作逐渐变为0或者超出上限；
4.原代码中每一段分配的空间为4096，我本来以为当该段的实际序列长度超过4096后会因为越界访问而出错，导致runtime error。因此构建了初始序列为2048（即一个段的长度），并往里面从首元素处插入了500000个元素，且保证其无法被消除。但实际运行时发现即使开的空间为p[0][4096]，仅有4096的容量，但往里面塞数直到p[0][504095]也不会报错（为什么）；所以不是runtime error的错误。但由于这种情况下，相当于没有分段，同03.cpp，由于每插入一个元素后面的都要后移一位，复杂度为O(n),总体为O(n^2)，因此会超时；


07.cpp
1.Wrong Answer
2.该代码在计算需要消除的开区间左开界l时，遇到l往左越界的情况（l<0）时没有考虑l的上一段连续空间长度为空（即plen[l.first-1]==0）的情况，直接将l移动到了这一段连续空间，从而无法继续搜索更前面的位置，导致有时能消除却不会进行消除而出错；
4.构造测例的思路是由于该代码将珠子序列以2048为一组，分为了不同组形成了二维数组，因此可以让初始序列分为0,1,2三组，使p[0]的末尾元素与p[2]的开头元素相同，通过插入珠子的方式让p[1]的珠子全部消除，使其为空数组，即plen[1]==0，这样若在p[2]开头插入一个与其原开头元素相同的珠子，则本来应该消掉的3个珠子，由于p[1]为空，左界l无法到p[0]末尾就是结束索引，从而导致这3个珠子无法消除，输出Wrong Answer；

08.cpp
1.Wrong Answer
2.没有考虑连消的情况
4.构造一个简答的连消情况，即可发现输出没有进行连消而为Wrong Answer；

09.cpp
1.runtime error;
2.在执行消除操作时，没有考虑到消除序列的左界和右界在同一分段的情况，若需要消除的序列左界l和右界r在同一个分段中，这时执行消除程序，就会将分段的长度设置为左界的秩+1，则下一步中len为分段长度减去右界所在位置一定为负数，之后分段长度也会被设置为负数，这样最后调用p2a（）进行合并时就会由于越界访问秩为负数的值而运行出错；
4.只要构造一个很短的序列，插入一个珠子后发生一次消除，则由于序列很短，搜索到的需要消除的序列左界l和右界r在同一个分段中，会导致合并时发生越界访问而出现runtime error；

10.cpp
1.Wrong Answer
2.在执行消除操作时，若消除的左，右界不在同一分段，则会把左界所在分段全部长度设置为0，相当于全部清空，导致出错；
4.只需要构造一个较长的序列，使其能分为两段，在插入下一个珠子后使需要消除的序列左右界在不同的分段，即会触发消除的bug，输出Wrong Answer；
