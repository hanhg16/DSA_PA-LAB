PA1-filename问题：
1.解题思路：
本题的结题思路参考了习题课内容：
第一步是假想存在一个滑动队列窗口，其尺寸对应某一天所需观察的前i天天数，则该队列中的最大值即为前i天最大确诊人数，由于每一天队列中的元素都会改变，且队列只会向后滑动，因此为了快速的求出该队列的最大值，采用了queap结构，即课上所讲的双端队列+队列的结构，这样双端队列中的首元素始终对应此时队列中的最大值，可用O（1）时间求出，由于在n天中，队列共要滑动n次，因此求每一天最大确诊人数的总时间为O(n）；
第二步是将第一步得出的n个结果存在一个int[]中，并将其从小到大排序，方便下一步的问询，此处采用了merge排序的方法，时间复杂度为O（nlogn）；
第三步是针对T个问询，挨个采用二分查找法得出小于p及大于等于p小于q的天数并输出，二分查找时间复杂度为O（logn），共进行了2T次，，总时间复杂度为O（Tlogn）；

2.使用数据结构
解题过程中用了两个Int[]分别存放每天确诊人数和最大确诊人数，空间复杂度为O（n）；
而在求每天最大确诊人数时，采用了queap的数据结构，该数据结构由两个队列组成，一个是普通队列，用于存放滑动窗口中的元素，一个是双端队列，用于存放此时队列中的最大值，两个队列都是在向量的基础上实现的，普通队列的空间复杂度等于滑动窗口的大小，由于滑动窗口的大小和数据有关，很不确定，保险起见此处按最大值估计为O（n）;而双端队列中每个元素为一个strcture,其中包含最大值的value和其count，用这种方式可以极大的简化其中的元素数量，节省空间和时间，因此此处的空间复杂度很低，可以忽略；

3.问题与解决方案
a.在逻辑正确的情况下上交代码进行了测试，发现答案错误；
解决方案：由于这道题的计算逻辑很简单，不会有问题，因此对三个计算部分依次进行了排查，发现排序和二分查找没有问题，问题出在所用的双端队列上，双端队列每次从队首弹出元素时，只将所有元素复制到一位并size--，而没有对末尾元素的值进行清理，导致末尾位置的残余值会在下一次使用该位置时被累加上。于是在每次size--时增加了对末尾元素的初始化；

b.上交测试，从第4个测例开始，显示运行时间超时；
解决方案：对每个计算部分的时间复杂度进行了估算，发现问题出在用于存放前n天确诊人数的队列上，由于该队列采用了向量的数据结构，因此在元素入队时时间复杂度为O（1），但出队时后续每个元素都要前移一位，时间复杂度为O（n）,而该题中平均每个元素都要进行一次入队和出队操作，乘起来的时间复杂度为O（n^2），显然会导致超时。因此将队列的数据结构改为列表，这样出队和入队的时间复杂度都为O（1）；
另外值得一提的是，双端队列采用的也是向量的数据结构，实际上也存在同样的问题，但由于双端队列中的元素远少于队列，因此此处的时间消耗大部分情况下可以接受，只有某些极端情况（如队列中的所有元素都是从大到小逆序排列的）时，会导致双端队列中的元素数量与队列中相等，但这种情况出现的概率很小，因此仍采用向量的数据结构,同时也提交了双端队列也采用列表的代码进行了对比，发现两者的时间消耗差不多，大部分情况下向量方式耗时更小；

4.复杂度估算
时间复杂度：参考1.中的分析，在第一步中除了求最大值的耗时O（n）外，每一次队列的滑动耗时也不可忽略，由于队列是单向滑动的，所以显然每一天的确诊人数xi最多进队出队各一次，也为O（1），因此此处总耗时也是O(n);第二步耗时O（nlogn）；第三步耗时O（Tlogn）；因此总耗时为O（（n+T）logn）;
空间复杂度：参考2.中的分析，空间复杂度为O（n）;


