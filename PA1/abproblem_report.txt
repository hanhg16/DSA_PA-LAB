PA1-A*B问题
1.解题思路：
整体思路是使用高精度乘法，将A,B按位相乘，结果存储在C中相应的位数上，最后统一进行进位处理得出C的值；
2.使用数据结构：
使用的数据结果包括char数组，int数组，其中char数组用于A*B的读入和C的输出，Int数组用于计算；
3.问题与解决方案
解题中遇到了很多问题：
a.
首先是如何提高A,B的读入以及C的输出效率，开始时是将A,B按位用scanf("%c")读入并存储在char[]数组中的，而C则是直接按位用printf("%d")输出int[]数组，这样做由于多次进行io操作，导致耗时极长；
解决方法：
使用scanf("%s"）直接读取A,B，再通过遍历char数组找到‘\0’从而得出数组长度，这样虽然仍需要O（n)次操作，但只需一次IO操作；
而C则是先转换为char[]数组，再使用printf("%d")一次性输出，同样只需要一次IO操作，实际上以500组10**500次方组数进行测试时，以int[]进行输出程序耗时8s左右，而改为char[]进行输出仅需要684ms，效率提升了10倍以上，但再OJ中两个版本的效率仅提高了3%左右，我不知道其中的原因；

b.高精度乘法的耗时问题；
首先可以确定，高精度乘法需要按位乘，因此时间复杂度一定为O（n），但实际应用中，双for循环中的语句越少，耗时也会成倍减少，开始时我的代码将进位操作写的过于复杂，每一次按位乘法之后都需要进行进位判断，且每一次进位判断都需要进行10次左右的计算；
解决方法：
参考了关于高精度乘法的博客：https://blog.csdn.net/lzoi_hmh/article/details/77414378；改进了进位判断的语句，每一次进位判断仅需3次计算；但仍然很耗时；
于是再次对双for循环里的代码进行优化，发现进位操作不需要放在双for循环中，只需要再按位乘法结束之后遍历数组进行进位操作即可，这样进位操作的复杂度由O(n**2)变为O(n)，极大节约了时间开销；

4.复杂度估算
时间复杂度：由于按位乘法，双for循环，所以显然为O(n**2)；
空间复杂度：对A，B和乘积C分别开辟了和其最大位数相同的char[]和int[]数组，该空间可以再至多500次两数乘法中反复使用，因此复杂度为O（n）;

5.问题：
实际上该算法仍不满足要求；我用最大数据进行了测试，即500组10**4999次方的数进行乘法并输出结果，耗时26s，远远超出了给定的1s时间，这意味着代码的效率至少要提高26倍；我暂时没有想到解决方案，一个可能的方法时将10进制按位乘改为10**5进制按位乘，但这建立在对于c++来说，5位数乘法与1位数乘法效率相同，这显然不成立；